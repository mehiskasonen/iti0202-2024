package ee.taltech.iti0202.sportsclub.sportsclub;

import ee.taltech.iti0202.sportsclub.training.Training;
import ee.taltech.iti0202.sportsclub.training.TrainingSession;
import ee.taltech.iti0202.sportsclub.users.Member;
import ee.taltech.iti0202.sportsclub.users.Trainer;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Represents a sports club in the system.
 */
public class SportsClub {
    private UUID id;

    private final String name;
    private HashSet<Member> members = new HashSet<>();
    private HashSet<Trainer> trainers = new HashSet<>();
    private List<Training> trainings = new ArrayList<>();
    private Map<Training, List<LocalDateTime>> schedule = new HashMap<>();
    private Optional<Strategy> discountStrategy = Optional.empty();

    /** Used by sortTrainers. Holds data generated by createTrainerIntegerMap */
    private Map<Trainer, Integer> trainerIntegerMap = new HashMap<>();


    /**
     * Constructs a new sports club with the given ID and name.
     *
     * @param name The name of the sports club.
     */
    public SportsClub(String name) {
        this.id = UUID.randomUUID();
        this.name = name;
    }


    /**
     * @return name of sports club.
     */
    public String getName() {
        return name;
    }


    /**
     * @param discountStrategy to set for club.
     */
    public void setDiscountStrategy(Strategy discountStrategy) {
        this.discountStrategy = Optional.ofNullable(discountStrategy);
    }

    /**
     * @return sports clubs current discount strategy.
     */
    public Optional<Strategy> getDiscountStrategy() {
        return discountStrategy;
    }

    /**
     * Method to list training sessions according to time given.
     * Ex. given time is 14:00, list all sessions starting from that time in ascending order.
     * @return map of sessions with its time.
     */
    public Map<TrainingSession, LocalTime> listSessions(LocalTime time) {
        Map<TrainingSession, LocalTime> resultMap = new HashMap<>();

        for (Training training : trainings) {
            for (TrainingSession session : training.getTrainingSessionList()) {
                if (!session.getStartTime().toLocalTime().isBefore(time)) {
                    resultMap.put(session, session.getStartTime().toLocalTime());
                }
            }
        }
        List<Map.Entry<TrainingSession, LocalTime>> sortedEntries = new ArrayList<>(resultMap.entrySet());
        sortedEntries.sort(Map.Entry.comparingByValue());

        LinkedHashMap<TrainingSession, LocalTime> sortedMap = new LinkedHashMap<>();
        for (Map.Entry<TrainingSession, LocalTime> entry : sortedEntries) {
            sortedMap.put(entry.getKey(), entry.getValue());
        }
        return sortedMap;
    }


    /**
     * Retrieves the list of members associated with this sports club.
     * A member can not be added twice.
     * @return The list of members associated with this sports club.
     */
    public HashSet<Member> getMembers() {
        return members;
    }

    /**
     * Can only add a member that is already not part of sports club.
     * @param member to add to sports club.
     * @return true if adding succeeded, else false.
     */
    public boolean addMember(Member member) {
        if (!members.contains(member)) {
            members.add(member);
            return true;
        }
        return false;
    }

    /**
     * Retrieves the list of trainers associated with this sports club.
     *
     * @return The list of trainers associated with this sports club.
     */
    public HashSet<Trainer> getTrainers() {
        return trainers;
    }

    /**
     * Can only add a training if is not already part os sports club.
     * @param training to be added to sports club
     * @return true if adding succeeded, else false.
     */
    public boolean addTraining(Training training) {
        if (!trainings.contains(training)) {
            trainings.add(training);
            populateTrainersList(training);
            return true;
        }
        return false;
    }

    /**
     * Method to populate trainers list when training gets added to sports club.
     * @param training
     */
    public void populateTrainersList(Training training) {
        for (TrainingSession session : training.getTrainingSessionList()) {
            session.getTrainer().ifPresent(trainer -> {
                if (!trainers.contains(trainer)) {
                    trainers.add(trainer);
                }
            });
        }
    }

    /**
     * Add trainer to specific sports club.
     * Trainer can only be added if the is already not a trainer there.
     *
     * @param trainer to be added to the Sports club.
     * @return boolean if adding is successful.
     */
    public boolean addTrainer(Trainer trainer) {
        if (!trainers.contains(trainer)) {
            trainers.add(trainer);
            return true;
        }
        return false;
    }

    /**
     * @return list of trainings the sports club has.
     */
    public List<Training> getTrainings() {
        return trainings;
    }


    /**
     * Organizes the trainings held by the sports club.
     * Trainings are listed in descending order based on the number of participants (over all sessions).
     * If multiple trainings have the same number of participants, they are further organized
     * based on the number of sessions they have, also in descending order.
     * [Training2, Training3, Training1]
     * Training1 = [Judo trainingSession1, Judo trainingSession2, Judo trainingSession3]
     * Training2 = [Joga trainingSession1, Joga trainingSession2]
     * Training3 = [Basketball trainingSession1]
     * Sessions have 0 participants, so they should be listed according to nr of sessions and output
     * should be List.of[Training1, Training2, Training3]
     */
    public List<Training> listTrainings() {
        return trainings.stream()
                .sorted(Comparator.comparingInt(this::calculateTotalParticipants)
                .thenComparingInt(training -> training.getTrainingSessionList().size()).reversed())
                .collect(Collectors.toList());
    }

    /**
     * Calculates the total number of participants across all sessions of a training.
     *
     * @param training The training for which to calculate the total number of participants.
     * @return The total number of participants across all sessions of the training.
     */
    private int calculateTotalParticipants(Training training) {
        return training.getTrainingSessionList().stream()
                .mapToInt(session -> session.getParticipants().size())
                .sum();
    }

    @Override
    public String toString() {
        return "SportsClub{" + "id=" + id + ", name='" + name + '\'' + ", members=" + members
                + ", trainers=" + trainers + ", trainings=" + trainings + '}';
    }

    /**
     * Sets a new schedule to Sports club.
     * @param schedule to be set.
     */
    public void setSchedule(Map<Training, List<LocalDateTime>> schedule) {
        this.schedule = schedule;
    }

    /**
     * Makes setting a new schedule for sports club easier.
     * @param training as key in built schedule.
     * @param times LocalDateTimes when training will take place.
     */
    public void buildSchedule(Training training, List<LocalDateTime> times) {
        if (schedule.containsKey(training)) {
            List<LocalDateTime> existingTimes = schedule.get(training);
            if (existingTimes != null) {
                existingTimes.addAll(times);
                schedule.put(training, existingTimes);
            }
        } else {
            schedule.put(training, times);
        }
    }

    /**
     * Retrieves the schedule for this training session.
     * @return The schedule mapping days of the week to start times.
     */
    public Map<Training, List<LocalDateTime>> getSchedule() {
        return schedule;
    }


    /**
     * Method to sort training sessions according to training session level enum (BEGINNER, INTERMEDIATE,
     * ADVANCED). If the level is same, then sort by participants count.
     * If that is same, then sort by starting time.
     *
     * @return list of sorted training sessions.
     */
    public List<TrainingSession> sortTrainingSessions() {
        List<TrainingSession> allTrainingSessions = trainings.stream()
                .flatMap(training -> training.getTrainingSessionList()
                        .stream()).distinct()
                .toList();

        Comparator<TrainingSession> sessionComparator = TrainingSession::compareByTrainingSessionLevel;

        return allTrainingSessions.stream()
                .sorted(sessionComparator
                    .thenComparing(TrainingSession::getParticipantsCount)
                    .thenComparing(TrainingSession::getStartTime)).collect(Collectors.toList());
    }

    /**
     * Method that sorts trainers by specialization count in descending order.
     * If the count is same, then sort by member count that have registered to their
     * training sessions in descending order.
     * if that is same, then sort alphabetically by trainers first name in ascending order.
     *
     * @return list of sorted trainers.
     */
    public List<Trainer> sortTrainers() {
        createTrainerIntegerMap();

        return trainers.stream()
                .sorted(Comparator.comparing(Trainer::getSpecializationCount)
                .thenComparing(this::getTrainersFollowing).reversed()
                        .thenComparing(Trainer::getName))
                .toList();
    }

    /**
     * Method to build trainer integer map, where key is trainer and value is integer
     * count of participants in all the sessions trainer is teaching at.
     */
    public void createTrainerIntegerMap() {
        for (Trainer trainer : trainers) {
            for (Training training : trainings) {
                for (TrainingSession session : training.getTrainingSessionList()) {
                    session.getTrainer().ifPresent(sessionTrainer -> {
                        if (trainer.equals(sessionTrainer)) {
                            int participantCount = session.getParticipantsCount();
                            trainerIntegerMap.merge(trainer, participantCount, Integer::sum);
                        }
                    });
                }
            }
        }
    }

    /**
     * Method that retrieves a trainers participant count collected from all sessions
     * that trainer gives.
     *
     * @param trainer to get the following of.
     * @return trainers following.
     */
    public int getTrainersFollowing(Trainer trainer) {
        return trainerIntegerMap.get(trainer);
    }

}
